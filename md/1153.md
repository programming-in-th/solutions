เพื่อความเข้าใจตรงกัน ขอสรุปเนื้อหาโจทย์โดยย่อและนิยามตัวแปรต่าง ๆ ใหม่ดังนี้: ในร้านค้าแห่งหนึ่งมีเจ้าของร้านอยู่สองคน วันนี้มีลูกค้าเข้าร้านมาขโมยเงินทั้งหมด $n$ คน เจ้าของร้านมีหน้าที่ตามไล่จับลูกค้าแต่ละคนเพื่อเก็บเงินคืนมา สำหรับกิจกรรมขโมยเงินของลูกค้าคนที่ $i$ จะขโมยเงิน ณ เวลา $start[i]$ เมื่อเจ้าของร้านคนใดคนหนึ่งตามไล่ไปจับ (ซึ่งจะจับได้เสมอ) จะกลับมาที่ร้าน ณ เวลา $end[i]$ พร้อมกับได้เงินคืนมา $pay[i]$ หน่วย ถามว่าในวันนี้เจ้าของร้านทั้งสองคนได้เงินรวมคืนมากสุดกี่หน่วย  

วิธีทำข้อนี้คือใช้ท่า Dynamic Programming 
สำหรับใครไม่ชอบอ่านเฉลยแบบยาว ๆ ก็ไปอ่านสรุปสูตรด้านล่างสุดได้เลย 

ต่อไปนี้ขอเรียกเจ้าสองร้านสองคนว่าคนที่ 1 และคนที่ 2 ตามลำดับ ตอนแรกทำการจัดเรียงข้อมูลของลูกค้าแต่ละคนโดยเรียงตามค่าของ $start[i]$ จากน้อยไปมาก ถ้าเท่ากันจะเรียงอย่างไรก็ได้

จากนั้นเริ่มนิยามสมการ Dynamic Programming ดังนี้
กำหนดให้ $dp(i, e)$ หมายถึงมูลค่าเงินมากสุดที่สามารถเก็บได้ เมื่อพิจารณาลูกค้าตั้งแต่คนที่ $i$ ไปถึงคนที่ $n$ เท่านั้น โดยหาก $e$ มีค่าเท่ากับ $0$ จะหมายถึงผู้ตามจับทั้งสองคนว่างและพร้อมที่จะตามจับลูกค้าคนอื่น แต่หาก $e$ ไม่เท่ากับ $0$ จะหมายถึงผู้ตามจับคนแรกกำลังตามจับลูกค้าคนอื่นอยู่และจะว่าง ณ เวลา $e$ เป็นต้นไป ส่วนคนที่สองยังว่างอยู่

โดยเราสนใจ parameter ของค่าเวลา $e$ เป็นสำคัญ นั่นคือ
ถ้า $e = 0$ หมายความว่าตอนนี้คนที่ 1 ว่างงาน (ยังไม่ได้ตามจับลูกค้าคนไหน) แสดงว่าสำหรับลูกค้าคนที่ $i$ ที่กำลังดูอยู่ จะมีกรณีให้พิจารณาแค่ เอาเลย หรือ ไม่เอา (หมายถึงว่าจะตามจับลูกค้าคนที่ $i$ เลยหรือไม่ตามจับก็ได้)
- ถ้าตามจับ ก็จะได้ว่า คนที่ 1 จะได้เงินจากกรณีนี้ $pay[i]$ หน่วย และไปดูลูกค้าคนต่อไป โดยเริ่มเวลาที่จะตามได้อีกทีตอนเวลา $end[i]$ ซึ่งก็คือไล่จบลูกค้าคนที่ $i$ เสร็จแล้วและพร้อมไล่จับลูกค้าคนอื่น ๆ ต่อไป จะได้สมการในกรณีนี้เป็น $$dp(i,e)=pay[i]+dp(i+1, end[i]) \text{ ; } e = 0$$
- ถ้าไม่ตามจับ ก็ปล่อยไป แล้วไปสนใจลูกค้าคนต่อไป นั่นคือคนที่ $i+1$ โดยเวลาก็ยังอยู่ที่เดิมคือ $e$ ซึ่งมีค่าเป็น $0$ ซึ่งจะได้สมการในกรณีนี้เป็น $$dp(i,e)=dp(i+1,e) \text{ ; } e = 0$$

จากทั้ง 2 กรณีของการสนใจค่าเวลา $e$ เมื่อเท่ากับ 0 (ก็คือกำลังว่างงาน) จะได้ว่า มูลค่าเงินสูงสุดเป็นไปตามสมการ 
$$dp(i, e) = \max(pay[i] + dp(i+1, end[i]), dp(i+1, e))$$ และเมื่อแทน $e$ ด้วย $0$
$$\therefore dp(i, e) = \max(pay[i]+dp(i+1, end[i]), dp(i+1, 0)) \text{ ; e = 0}$$

ถ้า $e \neq 0$ หมายความว่าตอนนี้คนที่ 1 กำลังไล่ตามจับลูกค้าสักคนจนถึงเวลา $e$ และกำลังพิจารณาลูกค้าคนที่ $i$ อยู่ว่าหลังจากไล่จับลูกค้าก่อนหน้านี้จบแล้วกำลังเริ่มจะจับลูกคนที่ $i$ ณ เวลา $e$ อย่างไรต่อดี ดังนั้นสิ่งที่จะทำคือ สำหรับลูกค้าคนที่ $i$ ที่กำลังดูอยู่ตอนนี้ จะเอาอย่างไร ถ้าไม่สนใจก็จะได้ว่า $dp(i, e) = dp(i+1, e)$ ทันที แต่ถ้าจะจับลูกค้าคนที่ $i$ ให้ได้ ก็จะมีกรณีให้พิจารณา 3 กรณี ซึ่งมาจากการดูจากช่วงเวลา $start[i]$ และ $end[i]$ ของลูกค้าคนที่ $i$ ว่าอยู่ในรูปไหนกับเส้นเวลา e ซึ่งได้แก่
 - กรณีที่ลูกค้าคนที่ $i$ จะเริ่มขโมยตั้งแต่หลังเวลา e นั่นคือ $start[i] \geq e$ นั่นแสดงว่ามูลค่าเงินรวมมากสุดที่จะได้จากการพิจารณาคนที่ $i$ ก็เหมือนกับเริ่มพิจารณาคนที่ $i$ โดยที่เวลาเริ่มจาก 0 เพราะแสดงว่าคนที่ 1 พร้อมเริ่มวิ่งไล่จับแล้ว (ว่างงานนั่นแหละ) ซึ่งจะได้สมการในกรณีนี้ว่า $$dp(i, e)=dp(i, 0) \text{ ; } e \neq 0 \text{ and } start[i] \geq e$$ 
 - กรณีที่ลูกค้าคนที่ $i$ มีเวลาจบอยู่หลัง ณ เวลาที่ $e$ เป็นต้นไป นั่นคือ $end[i] \geq e$ นั่นแสดงว่า พอคนที่ 1 ทำการไล่จับลูกค้าก่อนหน้านี้เสร็จมาจนถึงเวลาที่ $e$ แล้วจะจับลูกค้าคนที่ $i$ ต่อซึ่งถ้าตามจับจะต้องไปพร้อมเริ่มไล่จับอีกครั้ง ณ เวลาที่ $end[i]$ เป็นอย่างน้อยที่จะมีคนที่ 2 พร้อมไล่จับต่อ ฉะนั้นก็มองว่าที่ผ่านมาคนที่ 2 ได้ไล่ตามจับลูกค้าคนที่ $i$ มาตั้งแต่แรกแล้ว ฉะนั้นลูกค้าคนต่อไปที่จะพิจารณาก็คือลูกค้าคนแรกที่เวลาเริ่มต้นอยู่หลังตั้งแต่เวลาที่ $e$ เป็นต้นไป นำมาสู่การสร้างฟังก์ชันช่วยชื่อว่า $lr(time)$ ย่อมาจากคำว่า $\text{lower bound}$ ซึ่งมีนิยามตรง ๆ ว่าจะหา $index \text{ j}$ ตัวแรกที่ทำให้ $start[j] \geq e$ จะได้ว่า $$lr(time) = \min_{start[j] \geq time}(j)$$ แทนค่า $time$ ด้วยเวลาตั้งแต่ $e$ เป็นต้นไป จะได้ว่าเรากำลังจะหา $j$ ที่เท่ากับ $lr(e)$ ซึ่งตรงนี้สามารถทำ Binary Search หาค่า j ที่เหมาะสมได้ แต่ถ้าไม่มี j ดังกล่าวจะขอกำหนดให้ $\text{j} = n+1$ แทนว่าเลยขอบเขตของจำนวนลูกค้าทั้งหมดไปแล้ว ซึ่งจะไปสอดคล้องกับ $\text{base case}$ ในย่อหน้าต่อไป
 ฉะนั้นจากกรณีนี้ ทำให้ได้ว่ามูลค่าเงินรวมมากสุดที่จะได้คือ $$dp(i, e) = pay[i] + dp(lr(e), end[i]) \text{ ; } e \neq 0 \text{ and } end[i] \geq e$$
 - กรณีที่ลูกค้าคนที่ $i$ มีเวลาจบอยู่ก่อน ณ เวลาที่ $e$ นั่นคือ $end[i] < e$ นั่นแสดงว่า คนที่ 1 ก็ยังทำงานอยู่ไม่จบ ทำให้ลูกค้าคนที่ $i$ ที่กำลังดูอยู่ถูกคนที่ 2 ไล่ตามจนจบแล้วคนที่ 2 ก็ว่างงานต่อ ทำให้ต้องหาลูกค้าคนต่อไปที่เวลาเริ่มอยู่หลังลูกค้าคนที่ $i$ (ที่ตามจับเสร็จเมื่อกี้ได้เงินมาแล้ว $pay[i]$ หน่วย) ก็คือหาลูกค้า $index \text{ j}$ ตัวแรกที่ $start[j] \geq end[i]$ ซึ่งเท่ากับค่าของ $lr(end[i])$ ตามนิยามฟังก์ชันช่วยกรณีก่อนหน้านี้นั่นเอง และในกรณีเวลาที่จะมีใครสักคน (ไม่คนที่ 1 ก็ 2) ว่างแน่ ๆ คือเวลาที่ $e$ ทำให้มูลค่าเงินรวมมากสุดเป็นไปตามสมการดังนี้ $$dp(i,e)=pay[i]+dp(lr(end[i]), e) \text{ ; } e \neq 0 \text{ and } end[i] < e$$ 
 สรุปกรณีที่ $e \neq 0$ ได้ว่า $$
 dp(i,e)= 
  \max \begin{cases}
   dp(i+1, e)      &                     \text{; any }                                                    \\
    dp(i, 0)         & \text{; } e \neq 0 \text{ and } start_i \geq e   \\
	  pay[i] + dp(lb(e), end[i]) & \text{; } e \neq 0 \text{ and } end[i] \geq e  \\
	  pay[i] + dp(lb(end[i]), e)  & \text{; } e \neq 0 \text{ and } end[i] < e       \\
  \end{cases}
$$
 - จบกรณี $e \neq 0$
 - และเมื่อนำกรณี $e = 0$ มาพิจารณาร่วมด้วย จะได้ว่า $$dp(i, e) = \max(pay[i]+dp(i+1, end[i]), dp(i+1, 0)) \text{ ; e = 0}$$ จะเห็นได้ว่าพจน์ $dp(i+1,0)$ ก็คือพจน์เดียวกับ $dp(i+1,e)$ ซึ่งเหมือนกรณี $any$ ในสมการของ $e \neq 0$ ซึ่งสามารถย้าย ๆ ปรับ ๆ พจน์ที่คล้ายกันเหล่านี้ออกมาเป็นกรณีโด่ด ๆ ได้ ทำให้ได้สมการใหม่เป็น 
$$dp(i, e) = 
\begin{cases}  
  dp(i, 0)         & \text{; } e \neq 0 \text{ and } start_i \geq e   \\
  \max \begin{cases}
	  dp(i+1, e)                          & \text{; any }                                                    \\
	  pay[i] + dp(i+1, e)            & \text{; }  e = 0                                                 \\
	  pay[i] + dp(lb(end[i]), e)  & \text{; } e \neq 0 \text{ and } end[i] < e       \\
	  pay[i] + dp(lb(e), end[i]) & \text{; } e \neq 0 \text{ and } end[i] \geq e  \\
  \end{cases} & \text{; otherwise }
   \end{cases} \\
$$

เมื่อพิจารณา parameter เกี่ยวกับ $e$ เสร็จแล้ว ต่อมาจะพิจารณา parameter ของ $i$ ซึ่งแทนเลข index ของลูกค้าคนที่ $i$ ที่กำลังพิจารณาอยู่ที่เรียงข้อมูลแล้วจะได้ว่ากรณีที่ $1 \leq i \leq n$ ก็ไปพิจารณา parameter $e$ แทน และกรณีที่ $i > n$ จะได้ว่าเลข index ของลูกค้าไม่ได้อยู่ในขอบเขตของลูกค้าทั้งหมด ทำให้มูลค่าเงินรวมสูงสุดคือไม่ได้อะไรเลย จะได้สมการดังนี้ $dp(i, e) = 0 \text{ ; } i > n$ ซึ่งนี่คือกรณี $\text{base case}$ ด้วย จากการพิจารณาทุก parameter เหล่านี้จึงได้สูตรรวม ๆ เป็นดังนี้ 
$$dp(i, e) = 
\begin{cases}  
  0                  & \text{; } i > n                                                       \\
  dp(i, 0)         & \text{; } e \neq 0 \text{ and } start_i \geq e   \\
  \max \begin{cases}
	  dp(i+1, e)                          & \text{; any }                                                    \\
	  pay[i] + dp(i+1, e)            & \text{; }  e = 0                                                 \\
	  pay[i] + dp(lb(end[i]), e)  & \text{; } e \neq 0 \text{ and } end[i] < e       \\
	  pay[i] + dp(lb(e), end[i]) & \text{; } e \neq 0 \text{ and } end[i] \geq e  \\
  \end{cases} & \text{; otherwise }
   \end{cases} \\
$$
$\text{Note: } lb(time) = \min_{start[j] \geq time}(j)$

จากสูตรดังกล่าว คำตอบสุดท้ายอยู่ที่ $dp(1, 0)$ ซึ่งหมายถึงมูลค่าเงินรวมมากสุดของคนที่ 1 (และคนที่ 2)โดยกำลังพิจารณากิจกรรมของลูกค้าคนที่ $1$ โดยกำลังอยู่บนเส้นเวลา ณ เวลาที่ $0$ ซึ่งคือเวลาเริ่มต้นที่สุดของการไล่จับเลย

ทั้งนี้สังเกตว่าพจน์ของ $$pay[i] + dp(lb(end[i]), e) \text{ ; } e \neq 0 \text{ and } end[i] < e$$ และพจน์ของ $$pay[i] + dp(lb(e), end[i])  \text{ ; } e \neq 0 \text{ and } end[i] \geq e$$ สามารถย่อให้เหลือเพียงพจน์เดียวได้ จากการพิจารณาความมากน้อยของ $end[i]$ กับ $e$ ทำให้ได้พจน์ดังต่อไปนี้ $$pay[i] + dp(lb(\min(end[i], e)), \max(end[i], e)) \text{ ; } e \neq 0$$ ซึ่งจะได้สมการสุดท้าย สามารถนำไปเขียนโค้ดได้โดยตรงดังนี้
### สรุปสูตรข้อนี้
$$dp(i, e) = 
\begin{cases}  
  0                  & \text{; } i > n                                                       \\
  dp(i, 0)         & \text{; } e \neq 0 \text{ and } start_i \geq e   \\
  \max \begin{cases}
	  dp(i+1, e)                          & \text{; any }                                                    \\
	  pay[i] + dp(i+1, e)            & \text{; }  e = 0                                                 \\
	  pay[i] + dp(lb(\min(end[i], e)), \max(end[i], e)) & \text{; } e \neq 0 \\
  \end{cases} & \text{; otherwise }
   \end{cases} \\
$$
$\text{Note: } lb(time) = \min_{start[j] \geq time}(j)$

สุดท้ายนี้ขอแนะนำว่าให้เขียนโค้ดแบบสูตรแรกที่ไม่ย่อจะดีกว่าเพราะอ่านแล้วบอกที่มาของสมการได้ตรง ๆ แต่ถ้าชอบแบบขอสั้น ๆ และอ่านไม่รู้เรื่องก็เขียนตามสูตรสุดท้ายนี้ได้เลย (ซึ่งโค้ดด้านล่างนี้เขียนตามสูตรสุดท้าย)

## Code 
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1005;
int dp[N][N];

int main() {
  int n;
  scanf("%d", &n);
  vector<tuple<int, int, int>> in(n + 1);
  for (int i = 1; i <= n; ++i) {
    int p, v, k;
    scanf("%d%d%d", &p, &v, &k);
    in[i] = make_tuple(p, v, k);
  }

  sort(in.begin() + 1, in.end());
  vector<int> start(n + 1), end(n + 1), pay(n + 1);
  for (int i = 1; i <= n; ++i)
    tie(start[i], end[i], pay[i]) = in[i];

  for (int i = n; i >= 1; --i) {
    dp[i][0] = max(dp[i + 1][0], pay[i] + dp[i + 1][end[i]]);
    for (int e = 1000; e >= 1; --e) {
      if (start[i] >= e) {
        dp[i][e] = dp[i][0]; // free for activity[i]
        continue;
      }
      int j = lower_bound(s.begin() + i + 1, s.end(), min(e, end[i])) -
              start.begin();
      dp[i][e] = max(pay[i] + dp[j][max(end[i], e)], dp[i + 1][e]);
    }
  }
  printf("%d", dp[1][0]);
  return 0;
}
```
#### Time complexity and space complexity
สำหรับเวลาการทำงานข้อนี้ เนื่องจากมี state การคำนวณทั้งหมดเป็น $N*ALL\_TIME$ state ซึ่งคือมีลูกค้า N คน แต่ละคนอยู่ขอบเขตของเวลาทั้งหมด $ALL\_TIME = 1001$ ตามข้อจำกัดของโจทย์ แต่ละ state จะใช้เวลามากสุดตรงที่กรณี $e \neq n$ ที่ให้หาลูกค้าคนต่อไปที่เหมาะสม ซึ่งถ้าใช้ Binary Search ก็จะใช้เวลามากสุดคือ $\log{N}$ ต่อ state ดังนั้นเวลาการทำงานทั้งหมดจึงเป็น
$$O(N\times ALL\_TIME\times \log{N})$$ และใช้หน่วยความจำเท่ากับจำนวน state ทั้งหมดของสูตร ซึ่งจะได้เป็น $$O(N\times ALL\_TIME)$$ 
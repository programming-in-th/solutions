สำหรับข้อนี้ โดยเบื้องต้นแล้ว เราต้องรับค่ามาว่าหนังตอนที่ $i$ ต้องจ่ายราคาเท่าไหร่ 

แต่ถ้าเราอ่านโจทย์ไปเรื่อยๆจะสังเกตว่า ค่าที่โจทย์ต้องการไม่ใช่ค่าใช้จ่ายของการดูในแต่ละตอน แต่ต้องการค่าใช้จ่ายรวมที่เกิดจากการดูหลายๆตอน

ดังนั้นตอนรับข้อมูล แทนที่จะรับค่าตรงๆ ให้รับแล้ว **Quick Sum** ไปเลยจะประหยัดเวลาขึ้นมากเวลาจะเรียกค่าใช้จ่ายเมื่อลูกค้าชมสารคดีจากตอนที่ 1 ถึงตอนที่ใดๆ

ยกตัวอย่าง ถ้าค่าใช้จ่ายในการดูตอนที่ 1,2,3 เป็น 10,20,30 ตามลำดับ แทนที่จะเก็บเป็น `[10,20,30]` ก็ให้เก็บในรูปแบบ `[10,30,60]` แทน

โจทย์ต้องการให้ลูกค้าได้ดูจำนวนตอนมากที่สุดด้วยงบที่กำหนด ดังนั้นสิ่งที่เราต้องทำต่อคือ**การเรียงลำดับข้อมูล**ในอาเรย์ที่เก็บค่าจากการ Quick Sum (สำหรับโจทย์ข้อนี้ ค่าหลังการ Quick Sum ไม่ได้เรียงลำดับอัตโนมัติ เนื่องจากราคาติดลบได้) 

หลังจากนั้นเราก็ต้องทำการตรวจสอบว่า ด้วยงบประมาณที่มี จะสามารถดูได้มากที่สุดกี่ตอน 

ยกตัวอย่างเช่น สมมติให้ `[30,10,50,40]` เป็นข้อมูลที่ได้หลังการ Quick Sum ที่อธิบายว่าถ้าดู**รวม** 1 ตอนต้องใช้ 30 บาท แต่ถ้าดู**รวม** 2 ตอนจะใช้ 10 บาท เมื่อเรียงลำดับข้อมูลแล้ว (ได้เป็น `[10,30,40,50]`) จะเปลี่ยนการตีความเป็น "ถ้า 10 บาทดูได้ 2 ตอน 30 บาทก็ต้องดูได้ 2 ตอนเช่นกัน จะดูได้เพียงหนึ่งตอนไม่ได้" แทน

ส่วนสุดท้ายจะเป็นส่วนที่ให้งบประมาณของแต่ละคน แล้วโปรแกรมต้องตอบว่าดูได้มากที่สุดกี่ตอนเช่น `[10,30,40,50]` ถ้ามีงบ 35 บาทก็จะดูได้มากที่สุด 2 ตอน

ในส่วนนี้ มีสองทางเลือกในการค้นหาข้อมูล แบบแรกคือใช้ linear search แบบที่สองคือใช้ binary search (เร็วกว่าแน่นอน) ซึ่งจะเขียนด้วยตัวเองหรือจะใช้ `lower_bound()` ไม่ก็ `upper_bound()`ช่วยก็ได้

**ในส่วนหลังจากนี้ จะเป็นการแนะนำแนวทางการเขียนโค้ดเพิ่มเติมให้ หากอยากลองเขียนด้วยตัวเองก่อนให้หยุดอ่านที่ตรงนี้** 

ในส่วนแรกที่เก็บข้อมูลแบบ Quick Sum อาจเลือกใช้การเก็บแบบคู่ของข้อมูล(pair)แทน โดยให้ข้อมูลตัวหน้าเก็บค่าจากการทำ Quick Sumและข้อมูลตัวหลังเก็บว่าราคานี้เกิดจากการดูถึงตอนไหน

เช่นเก็บข้อมูลหลัง Quick Sum เป็น `[<30,1>,<10,2>,<50,3>,<40,4>]` แทน `[30,10,50,40]`

ที่เลือกเก็บแบบนี้เพราะหลังจากเราเรียงลำดับข้อมูล (อาจใช้ `sort()`) จะได้เป็น

`[<10,2>,<30,1>,<40,4>,<50,3>]` 

เราจะสามารถปรับเป็น

`[<10,2>,<30,2>,<40,4>,<50,4>]` 

โดยไม่ต้องพึ่งอาเรย์เสริมที่อาจต้องสร้างเพิ่มได้ ช่วยลดความสับสนตอนเขียนลง

หลังจากนั้น ถ้าจะทำการ binary search ก็ค่อยสร้างอาเรย์เสริมมาเก็บข้อมูลตัวแรกของคู่ข้อมูลทีหลังเพื่อให้ง่ายต่อการเขียนก็สามารถทำได้ในภายหลัง

Solution Code in C++ Language

```cpp
#include "bits/stdc++.h"
using namespace std;
#define ii pair<int, int>
int num[100010];
ii adj[100010];
#define f first
#define s second
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  int n, q;
  cin >> n >> q;

  for (int i = 1; i <= n; i++) {
    cin >> adj[i].f;
    adj[i].f += adj[i - 1].f;
    adj[i].s = i;
  }
  sort(adj + 1, adj + 1 + n);
  for (int i = 1; i <= n; i++) {
    num[i] = adj[i].f;
    adj[i].s = max(adj[i - 1].s, adj[i].s);
  }
  for (int i = 1; i <= q; i++) {
    int bud;
    cin >> bud;
    int upper = upper_bound(num + 1, num + 1 + n, bud) - (num + 1);
    cout << adj[upper].s << "\n";
  }
}
```
Time Complexity : $\mathcal{O}{(q\log n)}$

ก่อนอื่น ให้สังเกตคุณสมบัติเกี่ยวกับสตริงวงเล็บสมบูรณ์ 

สำหรับสตริงวงเล็บใด ๆ ถ้าเราสร้างอาร์เรย์ใหม่โดยการแทน `(` ด้วย 1 และ `)` ด้วย -1 จะได้ว่าสตริงนั้นจะเป็นสตริงวงเล็บสมบูรณ์ก็ต่อเมื่อสองเงื่อนไขต่อไปนี้เป็นจริงทั้งคู่

- prefix sum ณ ตำแหน่งใด ๆ ในอาร์เรย์นั้นไม่น้อยไปกว่า 0 
- ผลรวมตัวเลขในอาร์เรย์ในนั้นเท่ากับ 0

ข้อสังเกตนี้จะนำไปสู่วิธีการหาจำนวนสตริงวงเล็บสมบูรณ์ความยาวใด ๆ โดยการใช้ dynamic programming

ในการหาจำนวนสตริงวงเล็บสมบูรณ์ความยาว $n$ ให้ $dp[i][k]$ แทนวิธีการใส่ `(` หรือ `)` ให้ตามเงื่อนไขข้างต้น ในช่วง $[i...n]$ โดยที่ prefix sum ณ ตำแหน่ง $i-1$ มีค่าเท่ากับ $k$

จะได้ว่า $dp[n+1][k] = 1$ เมื่อ $k = 0$ มิเช่นนั้น $dp[n][k] = 0$

ทั้งนี้เพื่อความสะดวกในการนิยาม transition เราจะให้ $dp[i][k] = 0$ สำหรับ $i$ ใด ๆ และ $k< 0$

ในการ transition เราจะพิจารณาการใส่ `(` และ `)` ทั้งสองกรณี และยังต้องพิจารณาตำแหน่งที่โจทย์บังคับว่าต้องเป็น `(` หรือ `)` อีกด้วย ให้ $S$ แทนสตริงที่โจทย์ให้มา จะได้ว่า

$$
dp[i][k] = 
 \begin{cases} 
    dp[i+1][k+1]  && S[i] = \verb|"("| \\
    dp[i+1][k-1] && S[i] = \verb|")"|   \\
    dp[i+1][k+1]+dp[i+1][k-1] && S[i] = \verb|"."| \\
   \end{cases}
$$

ในการหา p-th lexicographical string นั้น เมื่อเรากำลังพิจารณาตำแหน่งที่ 1 อยู่ สมมติว่า $S[1] = \verb|"."|$ ให้เราพิจารณา $dp[2][1]$ ว่า $\geq p$ ไหม ถ้าใช่ ให้เราใส่ `(` ในตำแหน่งนี้ อัพเดทค่า $k$ แล้วไปต่อ มิเช่นนั้นให้ใส่ `)` อัพเดทค่า $p$ และ $k$ แล้วไปต่อ

ในกรณีที่ $S$ ในตำแหน่งนั้นไม่ใช่ `.` ให้เราใส่ไปตามนั้น อัพเดทค่า $k$ แล้วไปต่อเลย

อัลกอริธึมดังกล่าวสามารถสรุปเป็น code ได้ดังนี้

```cpp
char ans[];
int cur_k = 0;

for (int i = 1; i <= n; i++) {
  if (S[i] == '(') {
    ans[i] = '(';
    cur_k++;
  } else if (S[i] == ')') {
    ans[i] = ')';
    cur_k--;
  } else if (dp[i + 1][cur_k + 1] >= p) {
    ans[i] = '(';
    cur_k++;
  } else {
    ans[i] = ')';
    p -= dp[i + 1][cur_k + 1];
  }
}
```
บรรทัด `p -= dp[i + 1][cur_k + 1]` นั้นเป็นการปรับลำดับของสตริงที่โปรแกรมควรจะหา เมื่อใส่ `)` แล้ว

ทั้งนี้ ค่า $n$ ในโจทย์ข้อนี้อาจจะสูงถึง 5000 ซึ่งการเก็บทำให้ค่า $dp$ เก็บใน `long long` ไม่พอ แต่ในอัลกอริธึมขั้นต้น ค่า $dp$ ที่เราจำเป็นต้องใช้จะมีค่าไม่เกินค่าสูงสุดของ $p$ (ซึ่งก็คือ $10^{18}$ ตามโจทย์) ดังนั้นค่าที่เกินค่านั้นมา เราสามารถปรับเป็น $\infty$ ได้เลย

ดังนั้นเราจะแก้ปัญหานี้ได้ใน $\mathcal{O}(n^2)$


 
